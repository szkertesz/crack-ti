# JavaScript Interview Questions

## Table of Contents

HIGH - 43 questions (~55.8%)
MEDIUM - 27 questions (~35%)
LOW - 7 questions (~9%)

| No.  | Questions                                                                    | Priority |
|------|------------------------------------------------------------------------------|----------|
| 1    | Data Types                                                                   |          |
| 1.1  | [What are primitive data types?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-are-primitive-data-types)                                               | HIGH     |
| 1.2  | [What are the possible ways to create objects in JavaScript?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-are-the-possible-ways-to-create-objects-in-javascript)                  | MEDIUM   |
| 1.3  | [What is undefined property?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-undefined-property)                                                  | HIGH     |
| 1.4  | [What is null value?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-null-value)                                                          | HIGH     |
| 1.5  | [What is the difference between null and undefined?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-the-difference-between-null-and-undefined)                           | HIGH     |
| 1.6  | [What is the difference between window and document?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-the-difference-between-window-and-document)                          | HIGH     |
| 1.7  | [What is isNaN?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-isnan)                                                               | HIGH     |
| 1.8  | [What is the difference between let, const and var?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-the-difference-between-let-const-and-var)                           | HIGH     |
| 1.9  | [What are the differences between undeclared and undefined variables?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-are-the-differences-between-undeclared-and-undefined-variables)         | HIGH     |
| 1.10 | [What are global variables?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-are-global-variables)                                                   | HIGH     |
| 1.11 | [What are the problems with global variables?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-are-the-problems-with-global-variables)                                 | MEDIUM   |
| 1.12 | [What is NaN property?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-nan-property)                                                        | HIGH     |
| 1.13 | [What are classes in ES6?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-are-classes-in-es6)                                                     | HIGH     |
| 1.14 | [How do you check whether a string contains a substring?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#how-do-you-check-whether-a-string-contains-a-substring)                      | MEDIUM   |
| 1.15 | [How do you check if a key exists in an object?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#how-do-you-check-if-a-key-exists-in-an-object)                               | MEDIUM   |
| 1.16 | [How do you copy properties from one object to other?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#how-do-you-copy-properties-from-one-object-to-other)                         | HIGH     |
| 1.17 | [What is a proxy object?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-a-proxy-object)                                                      | LOW      |
| 1.18 | [What is the main difference between Object.values and Object.entries method?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-the-main-difference-between-objectvalues-and-objectentries-method) | MEDIUM   |
| 1.19 | [How can you get the list of keys of any object?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#how-can-you-get-the-list-of-keys-of-any-object)                              | MEDIUM   |
| 1.20 | [How do you create an object with prototype?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#how-do-you-create-an-object-with-prototype)                                  | LOW      |
| 1.21 | [What is a WeakSet?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-a-weakset)                                                           | MEDIUM   |
| 1.22 | [What are the differences between WeakSet and Set?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-are-the-differences-between-weakset-and-set)                            | MEDIUM   |
| 1.23 | [What is a WeakMap?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-a-weakmap)                                                           | MEDIUM   |
| 1.24 | [What are the differences between WeakMap and Map?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-are-the-differences-between-weakmap-and-map)                            | MEDIUM   |
| 1.25 | [What is Hoisting?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-hoisting)                                                            | HIGH     |
| 1.26 | [How do you assign default values to variables?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#how-do-you-assign-default-values-to-variables)                               | HIGH     |
| 2    | Context, Scope proto and Prototype                                           | *        |
| 2.1  | [What is the difference between Call, Apply and Bind?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-the-difference-between-call-apply-and-bind)                         | HIGH     |
| 2.2  | [What is scope in javascript?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-scope-in-javascript)                                                 | HIGH     |
| 2.3  | [What is the difference between proto and prototype?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-the-difference-between-proto-and-prototype)                          | LOW      |
| 2.4  | [What is prototype chain?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-prototype-chain)                                                     | HIGH     |
| 3    | JSON                                                                         | *        |
| 3.1  | [What is JSON and its common operations?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-json-and-its-common-operations)                                      | HIGH     |
| 3.2  | [How do you parse JSON string?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#how-do-you-parse-json-string)                                                | HIGH     |
| 3.3  | [Why do you need JSON?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#why-do-you-need-json)                                                        | MEDIUM   |
| 3.4  | [What is the purpose JSON stringify?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-the-purpose-json-stringify)                                          | HIGH     |
| 3.5  | [How do you define JSON arrays?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#how-do-you-define-json-arrays)                                               | LOW      |
| 4    | Array methods                                                                | *        |
| 4.1  | [What is the purpose of the array slice method?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-the-purpose-of-the-array-slice-method)                               | MEDIUM   |
| 4.2  | [What is the purpose of the array splice method?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-the-purpose-of-the-array-splice-method)                              | MEDIUM   |
| 4.3  | [What array methods do you know?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-array-methods-do-you-know)                                              | HIGH     |
| 4.4  | [What is the difference between Array.forEach() and Array.map()?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-the-difference-between-arrayforeach-and-arraymap)             | HIGH     |
| 5    | Functions                                                                    | *        |
| 5.1  | [What are lambda or arrow functions?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-are-lambda-or-arrow-functions)                                          | HIGH     |
| 5.2  | [What is a first class function?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-a-first-class-function)                                              | MEDIUM   |
| 5.3  | [What is a first order function?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-a-first-order-function)                                              | MEDIUM   |
| 5.4  | [What is a higher order function?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-a-higher-order-function)                                             | MEDIUM   |
| 5.5  | [What is a unary function?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-a-unary-function)                                                    | MEDIUM   |
| 5.6  | [What is the currying function?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-the-currying-function)                                               | MEDIUM   |
| 5.7  | [What is a pure function?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-a-pure-function)                                                     | HIGH     |
| 5.8  | [What are closures?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-are-closures)                                                           | HIGH     |
| 5.9  | [What is IIFE(Immediately Invoked Function Expression)? ](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-iifeimmediately-invoked-function-expression)                      | HIGH     |
| 5.10 | [What is a callback function?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-a-callback-function)                                                 | HIGH     |
| 5.11 | [What is an anonymous function?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-an-anonymous-function)                                               | MEDIUM   |
| 6    | Async JavaScript                                                             | *        |
| 6.1  | [What is a promise?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-a-promise)                                                           | HIGH     |
| 6.2  | [Why do you need a promise?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#why-do-you-need-a-promise)                                                   | HIGH     |
| 6.3  | [What are the three states of promise?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-are-the-three-states-of-promise)                                        | HIGH     |
| 6.4  | [Why do we need callbacks?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#why-do-we-need-callbacks)                                                    | HIGH     |
| 6.5  | [What is a callback hell?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-a-callback-hell)                                                     | HIGH     |
| 6.6  | [What is promise chaining?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-promise-chaining)                                                    | HIGH     |
| 6.7  | [What is promise.all?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-promiseall)                                                         | MEDIUM   |
| 6.8  | [What is the purpose of race method in promise?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-the-purpose-of-race-method-in-promise)                               | MEDIUM   |
| 6.9  | [What is the use of setTimeout?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-the-use-of-settimeout)                                               | HIGH     |
| 6.10 | [What is the use of setInterval?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-the-use-of-setinterval)                                              | HIGH     |
| 6.11 | [What is an event loop?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-an-event-loop)                                                       | HIGH     |
| 6.12 | [What is call stack?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-call-stack)                                                          | HIGH     |
| 7    | Common                                                                       | *        |
| 7.1  | [What is a strict mode in javascript?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-a-strict-mode-in-javascript)                                         | MEDIUM   |
| 7.2  | [What are PWAs?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-are-pwas)                                                               | MEDIUM   |
| 7.3  | [How do you validate an email in javascript?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#how-do-you-validate-an-email-in-javascript)                                  | HIGH     |
| 7.4  | [How do you get the current url with javascript?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#how-do-you-get-the-current-url-with-javascript)                              | MEDIUM   |
| 7.5  | [What is tree shaking?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-tree-shaking)                                                        | LOW      |
| 7.6  | [What is memoization?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-memoization)                                                         | MEDIUM   |
| 7.7  | [What are modules?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-are-modules)                                                            | HIGH     |
| 7.8  | [Why do you need modules?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#why-do-you-need-modules)                                                     | HIGH     |
| 7.9  | [How do you detect a mobile browser?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#how-do-you-detect-a-mobile-browser)                                          | LOW      |
| 7.10 | [How do you detect javascript disabled in the page?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#how-do-you-detect-javascript-disabled-in-the-page)                           | LOW      |
| 7.11 | [What is a rest parameter?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-a-rest-parameter)                                                    | HIGH     |
| 7.12 | [What is a spread operator?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-a-spread-operator)                                                   | HIGH     |
| 7.13 | [How do you encode an URL?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#how-do-you-encode-an-url)                                                    | MEDIUM   |
| 7.14 | [How do you decode an URL?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#how-do-you-decode-an-url)                                                    | MEDIUM   |
| 7.15 | [What is nodejs?](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-nodejs)                                                              | HIGH     |

## Data Types

### What are primitive data types?
- Primitive values (immutable values)
    - **Boolean** type
    [represents a logical entity and can have two values: `true` and `false`]
    - **Null** type
    - **Undefined** type
    - **Number** type
    - **BigInt** type
    - **String** type
    [is used to represent textual data]
    - **Symbol** type
    [a unique and immutable primitive value and may be used as the key of an Object property]
- Objects (collections of properties, a property is an association between a name (or key) and a value)

### What are the possible ways to create objects in JavaScript?

- with `new` keyword
    ```javascript
    const myCar = new Object();
    myCar.make = 'Ford';
    myCar.model = 'Mustang';
    myCar.year = 1969;
    ```
- using an object initializer
    ```javascript
    const myCar = {
        make: 'Ford',
        model: 'Mustang',
        year: 1969
    };
    ```
### What is undefined property?
- A variable that has not been assigned a value
- has the value undefined.

### What is null value?

- is one of JavaScript's primitive values and is treated as falsy for boolean operations
- has exactly one value: null
- represents the intentional absence of any object value

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/null

### What is the difference between null and undefined?
(beware of the differences between equality (==) and identity (===) operators)
```javascript
typeof null          // "object" (not "null" for legacy reasons)
typeof undefined     // "undefined"
null === undefined   // false
null  == undefined   // true
null === null        // true
null  == null        // true
!null                // true
isNaN(1 + null)      // false
isNaN(1 + undefined) // true
```
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/null#difference_between_null_and_undefined

### What is the difference between window and document?

- **window**

    The `Window` interface represents a window containing a DOM document; the `document` property points to the DOM document loaded in that window.

    `document.defaultView` returns the window object associated with a document, or `null` if none is available

    `window.document` returns a reference to the document contained in the window

    A global variable, `window`, representing the window in which the script is running, is exposed to JavaScript code.

    In a tabbed browser, each tab is represented by its own `Window` object; the global `window` seen by JavaScript code running within a given tab always represents the tab in which the code is running.

    https://developer.mozilla.org/en-US/docs/Web/API/Window


    `window` is the execution context and global object for that context's JavaScript.

    Each browser tab has its own top-level `window` object.

    Each `<iframe>` element has its own `window` object too, nested within a parent window.

    Each of these windows gets its own separate global object. `window.parent` and `window.top` might refer to enclosing windows, giving access to other execution contexts.

    `window` properties include: `setTimeout()`, `setInterval()` -- binding event handlers to a timer; `location` -- giving the current URL; `history` (w/ `back()`, `forward()` methods); `navigator`, etc.

    https://stackoverflow.com/questions/9895202/what-is-the-difference-between-window-screen-and-document-in-javascript#answer-41927247

- **document**

    The `Document` interface represents any web page loaded in the browser and serves as an entry point into the web page's content, which is the DOM tree.

    It provides functionality globally to the document, like how to obtain the page's URL and create new elements in the document.

    The `Document` interface describes the common
    
    properties (`Document.contentType`, `Document.fonts`, `Document.links`, `Document.activeELement`, `Document.body`, `Document.children`),

    methods (`Document.createElement()`, `Document.createEvent()`, `Document.getElementById()`, `Document.querySelector()`) and

    events (`scroll`, `animationend`, `drag`, `keydown`, `readystatechange`, `touchstart`, `pointerenter`) for any kind of document.

    Depending on the document's type (e.g. HTML, XML, SVG, …), a larger API is available: HTML documents, served with the `"text/html"` content type, also implement the `HTMLDocument` interface (w/ eg. `Document.location`, `Document.Title`, `Document.ReadyState`), whereas XML and SVG documents implement the `XMLDocument` interface.


### What is isNaN?

The `isNaN()` function determines whether a value is `NaN` or not.

(it is not possible to use the equality operators (== and ===) to compare a value against `NaN` to determine whether the value is `NaN` or not, because both `NaN == NaN` and `NaN === NaN` evaluate to `false`)
The `isNaN()` function provides equality check against NaN.

If `isNaN(x)` returns `false`, you can use `x` in an arithmetic expression not making the expression return `NaN`.

```javascript
isNaN(NaN);       // true
isNaN(undefined); // true
isNaN({});        // true

isNaN(true);      // false
isNaN(null);      // false
isNaN(37);        // false

// strings
isNaN('37');      // false: "37" is converted to the number 37 which is not NaN
isNaN("37,5");    // true
isNaN('blabla');   // true: "blabla" is converted to a number. Parsing this as a number fails and returns NaN
isNaN('123ABC');  // true:  parseInt("123ABC") is 123 but Number("123ABC") is NaN
isNaN('');        // false: the empty string is converted to 0 which is not NaN
isNaN(' ');       // false: a string with spaces is converted to 0 which is not NaN

// dates
isNaN(new Date());                // false
isNaN(new Date().toString());     // true
```
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isNaN

### What is the difference between let, const and var?

`let`, `const` & `var` are variable declarations

`let` and `const` declarations are scoped to the block statement that they are declared in. variables created with `var` are not block-scoped, but only local to the function (or global scope) that the block resides within

temporal dead zone apply to both `let` and `const`

- **let**

    The `let` declaration declares a block-scoped local variable

    allows you to declare variables that are limited to the scope of a block statement, or expression on which it is used, unlike the `var` keyword, which declares a variable globally, or locally to an entire function.
    
    The other difference between `var` and `let` is that the latter is initialized to a value only when a parser evaluates it

    A `let` or `const` variable is said to be in a *"temporal dead zone" (TDZ)* from the start of the block until code execution reaches the line where *the variable is declared and initialized with a value*.
    This differs from `var` variables, which will return a value of `undefined` if they are accessed before they are declared.
    ```javascript
    { // TDZ starts at beginning of scope
      console.log(bar); // undefined
      console.log(foo); // ReferenceError
      var bar = 1;
      let foo = 2; // End of TDZ (for foo)
    }
    ```

    Just like `const` the `let` does not create properties of the `window` object when declared globally (in the top-most scope):
    ```javascript
    var x = 'global';
    let y = 'global';
    console.log(this.x); // "global"
    console.log(this.y); // undefined
    ```
    Many issues with `let` variables can be avoided by declaring them at the top of the scope in which they are used

    Redeclaring the same variable within the same function or block scope raises a `SyntaxError`.
    ```javascript
    if (x) {
      let foo;
      let foo; // SyntaxError thrown.
    }
    ```

- **const**

    Constants are block-scoped, like `let` variable declarations. The value of a `const` can't be changed through reassignment (i.e. by using the assignment operator `=`), and it can't be redeclared, creates a read-only reference to a value. However, if a constant is an object or array its properties or items can be updated or removed.

    An initializer for a constant is required. You must specify its value in the same declaration.

    Global constants do not become properties of the `window` object, unlike `var` variables.

    https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const

- **var**

    `var` declarations, wherever they occur, are processed before any code is executed. This is called hoisting. It's initial value is `undefined`.

    Only a variable's declaration is hoisted, not its initialization. The initialization happens only when the assignment statement is reached. Until then the variable remains undefined (but declared):

    ```javascript
    'use strict';

    function do_something() {
        console.log(bar); // undefined (note: not ReferenceError)
        var bar = 111; // the initialization w/ the assignment statement
        console.log(bar); // 111
    }

    // the code above is interpreted as:
    function do_something() {
        var bar; // the declaration happened and it is hoisted
        console.log(bar);
        bar = 111;
        console.log(bar);
    }
    ```

    The scope of a variable declared with `var` is its current execution context and closures thereof, which is either the enclosing function and functions declared within it, or, for variables declared outside any function, global.

### What are the differences between undeclared and undefined variables?

- **Undefined**: when a variable has been declared but has not been assigned with any value.
    ```javascript
    var a;
    console.log(a)  // undefined
    ```

- **Undeclared**: when we try to access any variable that is not initialized or declared earlier using `let`, `const` or `var` keyword.
    ```javascript
    console.log(myVariable) //ReferenceError: myVariable is not defined
    ```

### What are global variables?
When you declare a variable outside of any function, it is called a *global variable*, because it is available to any other code in the current document. When you declare a variable within a function, it is called a *local variable*, because it is available only within that function.
(the global scope is the scope that contains, and is visible in all other scopes)

### What are the problems with global variables?
- **Variable naming collisions** - If you're working on a team and both yourself and your co-worker use the same variable name on the global scope, the variable defined last will overwrite the initial variable.

- **Security** - Specifically on the web, every user has access to the Window (or global) object. By putting variables on the global scope, you give any user the ability to see or change your variables.

3) **Performance** - This is almost negligible, but it still exists. The way JavaScript variable lookups work is the JavaScript engine will do a lookup on the current scope the variable is being looked up in. If it can't find it, it will do a look up on the next parent scope. If it doesn't find it there, it will continue looking upward until it reaches the global object looking for that variable. If all of your variables are located on the global scope, the JavaScript engine will always have to go through every scope in order to finally reach the global scope to find the variable.

### What is NaN property?
NaN - a value representing Not-A-Number, typically encountered when the result of an arithmetic operation cannot be expressed as a number
- If NaN is involved in any mathematical operation, the result is also NaN.
- When NaN is one of the operands of any relational comparison (>, <, >=, <=), the result is always false.
- NaN compares unequal (via ==, !=, ===, and !==) to any other value — including to another NaN value.
- NaN is also one of the falsy values in JavaScript.

### What are classes in ES6?
Classes are a template for creating objects. They encapsulate data with code to work on that data.

the class syntax has two components: class expressions and class declarations

- **class declaration**

     One way to define a class, using the `class` keyword with the name of the class

     classes must be defined before they can be constructed

     ```javascript
    const p = new Rectangle(); // ReferenceError

    class Rectangle {}
     ```

- **class expression**
    another way to define a class. Class expressions can be named or unnamed
    ```javascript
    // unnamed
    let Rectangle = class {
        constructor(height, width) {
            this.height = height;
            this.width = width;
        }
    };
    ```
    ```javascript
    // named
    Rectangle = class Rectangle2 {
        constructor(height, width) {
            this.height = height;
            this.width = width;
        }
    };
    ```

    The body of a class is the part that is in curly brackets `{}` in which you define class members, such as methods or constructor

### How do you check whether a string contains a substring?

```javascript
includes(searchString)
includes(searchString, position) // optional - the position within the string at which to begin searching for searchString. (Defaults to 0.)
```

```javascript
const sentence = 'The quick brown fox jumps over the lazy dog.';

const word = 'fox';

console.log(`The word "${word}" ${sentence.includes(word) ? 'is' : 'is not'} in the sentence`); // "The word "fox" is in the sentence"
```

### How do you check if a key exists in an object?
```javascript
const example = {
    prop: 'exists'
};

example.hasOwnProperty('prop'); // returns true if the specified property is a direct (not inherited) property of the object (does not check in the object's prototype chain)
'prop' in example; // returns true if the specified property is in the specified object or its prototype chain

example.prop !== undefined
example['prop'] !== undefined
```


### How do you copy properties from one object to other?

```javascript
Object.assign(target, ...sources)
```

```javascript
const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };

const returnedTarget = Object.assign(target, source);

console.log(target); // Object { a: 1, b: 4, c: 5 }
console.log(returnedTarget === target); // true

const target2 = {...target, ...source}
console.log(target2); // Object { a: 1, b: 4, c: 5 }

for (let key in source) {
    target[key] = source[key]
}
```

### What is a proxy object?

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy

### What is the main difference between Object.values and Object.entries method?

`Object.values()` method returns an array of a given object's own enumerable property values

`Object.entries()` method returns an array of a given object's own enumerable string-keyed property [key, value] pairs.

```javascript
const object1 = {
  a: 'somestring',
  b: 42,
  c: false
};

console.log(Object.values(object1)); // Array ["somestring", 42, false]

console.log(Object.entries(object1)); // [ ['a', 'somestring'], ['b', 42], ['c', false] ]
```

### How can you get the list of keys of any object?

```javascript
Object.keys(obj) // returns an array of a given object's own enumerable property names
```

```javascript
const object1 = {
  a: 'somestring',
  b: 42,
  c: false
};

console.log(Object.keys(object1)); // Array ["a", "b", "c"]
```

### How do you create an object with prototype?
The `Object.create()` method creates a new object, using an existing object as the prototype of the newly created object.

```javascript
const person = {
  isHuman: false,
  printIntroduction: function() {
    console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);
  }
};

const me = Object.create(person);

me.name = 'Matthew'; // "name" is a property set on "me", but not on "person"
me.isHuman = true; // inherited properties can be overwritten

me.printIntroduction(); // "My name is Matthew. Am I human? true"
```

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create

### What is a WeakSet?

`WeakSet` objects are collections of objects (only!). Just as with Sets, each object in a `WeakSet` may occur only once; all objects in a `WeakSet`'s collection are unique.

```javascript
const ws = new WeakSet();
const foo = {};
const bar = {};

ws.add(foo);
ws.add(bar);

ws.has(foo);    // true
ws.has(bar);    // true

ws.delete(foo); // removes foo from the set
ws.has(foo);    // false, foo has been removed
ws.has(bar);    // true, bar is retained
```

### What are the differences between WeakSet and Set?

`Set` objects are collections of values. You can iterate through the elements of a set in insertion order. A value in the `Set` may only occur once; it is unique in the `Set`'s collection.

a `Set` is like an array that can only contain unique values but we can still iterate through it like an array using methods like for loops and `.forEach`.

Similar to a `Set`, `WeakSet` is a collection of objects that are unique from each other but differs because `WeakSet` can only store objects and cannot contain arbitrary values of any type like strings or numbers.

`WeakSet`s use weak references

`WeakSet` is not enumerable. This means there is no way to loop over the items contained within it because there is no list of current objects stored in the collection


    If you need to store additional data temporarily and don’t want to worry about cleaning up the memory or how the objects are removed, then use weak references

https://blog.logrocket.com/weakmap-weakset-understanding-javascript-weak-references/

### What is a WeakMap?

The `Map` object holds key-value pairs and remembers the original insertion order of the keys. Any value (both objects and primitive values) may be used as either a key or a value.

`Map` is like an object where we can store key-value pairs and access the values contained within the `Map` through the key. Unlike a standard object in JavaScript, we must use the `.get()` method to access the values.

In comparison to a `Map`, a `WeakMap` is very much the same but the references it holds are weak references, meaning it won’t prevent garbage collection from removing values it references if they are not strongly referenced elsewhere.

`WeakMap` is not enumerable due to the weak references.

we must use objects as the keys, but the values can be any arbitrary value like a string or number.

```javascript
const wm1 = new WeakMap();
const wm2 = new WeakMap();

const obj1 = {};
const obj2 = window;

wm1.set(obj1, 100);
wm1.set(obj2, 'Hello');
wm2.set(obj1, obj2); // You can set the value to be anything including an object or function
wm2.set(obj2, undefined); // Or, undefined
wm1.set(wm2, wm1); // Or, even a WeakMap itself

wm1.get(obj1); // 100

wm1.has(obj1); // true
wm1.delete(obj1);
wm1.has(obj1); // false
```

    If you need to store additional data temporarily and don’t want to worry about cleaning up the memory or how the objects are removed, then use weak references

https://blog.logrocket.com/weakmap-weakset-understanding-javascript-weak-references/

### What are the differences between WeakMap and Map?

- In comparison to a `Map`, a `WeakMap` is very much the same but the references it holds are weak references

- `WeakMap` is not enumerable due to the weak references.

- we must use objects as the keys

### What is Hoisting?
JavaScript Hoisting refers to the process whereby the interpreter appears to move the declaration of functions, variables or classes to the top of their scope, prior to execution of the code.

Hoisting allows functions to be safely used in code before they are declared.

Variable and class declarations are also hoisted, so they too can be referenced / used before they are declared.

- function hoisting
  ```javascript
  catName("Tiger");

  function catName(name) {
      console.log(`My cat's name is ${name}`);
  }
  ```

- variable hoisting

    JavaScript only hoists declarations, not initializations

    - `var` hoisting

        ```javascript
        console.log(num); // Default initialization: returns 'undefined' from hoisted var declaration (not 6)
        var num; // Declaration
        num = 6; // Initialization
        console.log(num); // Returns 6 after the line with initialization is executed.
        ```

    - `let` and `const` hoisting

        Variables declared with `let` and `const` are also hoisted but, unlike `var`, are not initialized with a default value.

        ```javascript
        console.log(num); // Throws ReferenceError exception as the variable value is uninitialized
        let num = 6; // Initialization
        ```

    - `class` hoisting (declarations only!)

        while functions can be called in code that appears before they are defined, class declarations must be defined before they can be constructed

        ```javascript
        const p = new Rectangle(); // ReferenceError

        class Rectangle {}
        ```

https://developer.mozilla.org/en-US/docs/Glossary/Hoisting

### How do you assign default values to variables?

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator#assigning_a_default_value_to_a_variable

```javascript
const myText = ''; // An empty string (which is also a falsy value)

const notFalsyText = myText || 'Hello world';
console.log(notFalsyText); // Hello world

const preservingFalsy = myText ?? 'Hi neighborhood';
console.log(preservingFalsy); // '' (as myText is neither undefined nor null)
```

```javascript
let isHappyHour = '🍺';

// Logical Operator
isHappyHour = isHappyHour || '🍵'; // '🍺'
// ! any falsy value will not be used. If you only need to filter out null or undefined, consider using the nullish coalescing operator.

// Ternary
isHappyHour = isHappyHour ? isHappyHour : '🍵'; // '🍺'

// If/Else
if (isHappyHour) { 
  isHappyHour = isHappyHour 
} else { 
  isHappyHour = '🍵' 
}
```

### Context, Scope proto and Prototype

- Global context

    outside of any function (this refers to the global object whether in strict mode or not)

- Function context

    inside a function

**Execution Context**

- **Global Execution Context (GEC)**
    Execution Context => Execution Context Object (ECO)
    1. Creation phase of EC
       1. Creation of the Variable Object (VO) or *Environment Record*
          1. for each variable declared with the `var` keyword, a property is added to VO that points to that variable and is set to 'undefined'. = **Hoisting**
          2. every function declaration, a property is added to the VO, pointing to that function, and that property is stored in memory

       2. Creation of the Scope Chain

            a mechanism that determines how accessible a piece of code is to other parts of the codebase

            When a function is defined in another function, the inner function has access to the code defined in that of the outer function, and that of its parents. This behavior is called **lexical scoping**.

            However, the outer function does not have access to the code within the inner function.

       3. Setting the value of the `this` keyword

            - In the GEC (outside of any function and object), this refers to the global object — which is the window object.

            - In objects, the `this` keyword doesn't point to the GEC, but to the object itself.

    2. Execution phase

        Up until this point, the VO contained variables with the values of `undefined`.

        JavaScript engine reads the code in the current Execution Context [EC] once more, then *updates the VO with the actual values of* these *variables*

        The **Execution Stack**, also known as the **Call Stack**, keeps track of all the ECs created

        JavaScript is a single-threaded language => when other actions, functions, and events occur, an EC is created for each of these events ~ `Execution Stack`

        1. When scripts load in the browser, the `Global Context` is created as the *default context* and is placed at the bottom of the execution stack.

        2. The JS engine then searches for function calls in the code. For each function call, a new FEC is created for that function and is placed on top of the currently executing EC.

            The EC at the top of the Execution stack becomes the **active Execution Context**, and will always get executed first by the JS engine.

        3. As soon as the execution of all the code within the active EC is done, the JS engine pops out that particular function's EC of the execution stack, moves towards the next below it, and so on.

- **Function Execution Context (FEC)**

    1. Creation phase

       1. Creation of 'argument' object

            an array-like object, which includes all of the arguments supplied to the function

       2. Scoping

            Each FEC creates its scope

       3. Setting the value of the `this` keyword

            FEC doesn't create the `this` object. Rather, it get's access to that of the environment it is defined in. Eg. if it's defined in the GEC, it points to the `window` object.

| GLOBAL EXECUTION CONTEXT | FUNCTION EXECUTION CONTEXT |
|---|---|
| Creates a Global Variable object that stores function and variables declarations. | Doesn't create a Global Variable object. Rather, it creates an argument object that stores all the arguments passed to the function. |
| Creates the `this` object that stores all the variables and functions in the Global scope as methods and properties.| Doesn't create the `this` object, but has access to that of the environment in which it is defined. Usually the `window` object. |
| Can't access the code of the Function contexts defined in it | Due to scoping, has access to the code(variables and functions) in the context it is defined and that of its parents |
| Sets up memory space for variables and functions defined globally | Sets up memory space only for variables and functions defined within the function.|

https://javascript.info/closure

In JavaScript, every running function, code block {...}, and the script as a whole have an internal (hidden) associated object known as the `Lexical Environment`.

The *Lexical Environment* object consists of two parts:
- `Environment Record` – an object that stores all local variables as its properties (and some other information like the value of this).

  A “variable” is just a property of the special internal object, Environment Record. “To get or change a variable” means “to get or change a property of that object”.

- A `reference to the outer lexical environment`, the one associated with the outer code.

A **function** is also a value, like a variable. The difference is that a Function Declaration is instantly fully initialized.

When a function runs, at the beginning of the call, a new Lexical Environment is created automatically to store local variables and parameters of the call -- *inner Lexical Environment* (The outer Lexical Environment could be the global Lexical Environment.)

*When the code wants to access a variable – the inner Lexical Environment is searched first, then the outer one, then the more outer one and so on until the global one.*


### What is the difference between Call, Apply and Bind?

- `call` invokes the function and allows you to pass in arguments one by one

    ```javascript
    var person1 = {firstName: 'Jon', lastName: 'Kuperman'};
    var person2 = {firstName: 'Kelly', lastName: 'King'};

    function say(greeting) {
        console.log(greeting + ' ' + this.firstName + ' ' + this.lastName);
    }

    say.call(person1, 'Hello'); // Hello Jon Kuperman
    say.call(person2, 'Hello'); // Hello Kelly King
    ```

- `apply` invokes the function and allows you to pass in arguments as an array.

    ```javascript
    var person1 = {firstName: 'Jon', lastName: 'Kuperman'};
    var person2 = {firstName: 'Kelly', lastName: 'King'};

    function say(greeting) {
        console.log(greeting + ' ' + this.firstName + ' ' + this.lastName);
    }

    say.apply(person1, ['Hello']); // Hello Jon Kuperman
    say.apply(person2, ['Hello']); // Hello Kelly King
    ```

- `bind` returns a new function, allowing you to pass in a `this` array and any number of arguments.
    ```js
    var person1 = {firstName: 'Jon', lastName: 'Kuperman'};
    var person2 = {firstName: 'Kelly', lastName: 'King'};

    function say() {
        console.log('Hello ' + this.firstName + ' ' + this.lastName);
    }

    var sayHelloJon = say.bind(person1);
    var sayHelloKelly = say.bind(person2);

    sayHelloJon(); // Hello Jon Kuperman
    sayHelloKelly(); // Hello Kelly King
    ```

    more to `bind`: extract a method from an object, then later call that function and expect it to use the original object as its `this` <= create a bound function from the function, using the original object

    ```javascript
    this.x = 9; // 'this' refers to the global object (e.g. 'window') in non-strict mode
    const module = {
      x: 81,
      getX() {
          return this.x;
      },
    };

    module.getX(); // returns 81

    const retrieveX = module.getX;
    retrieveX(); //  returns 9; the function gets invoked at the global scope

    //  Create a new function with 'this' bound to module
    const boundGetX = retrieveX.bind(module);
    boundGetX(); //  returns 81
    ```

### What is scope in javascript?
A mechanism that determines how accessible a piece of code is to other parts of the codebase

When a function is defined in another function, the inner function has access to the code defined in that of the outer function, and that of its parents. This behavior is called **lexical scoping**.

However, the outer function does not have access to the code within the inner function.

### What is the difference between proto and prototype?

https://stackoverflow.com/questions/9959727/proto-vs-prototype-in-javascript#answer-42002749

### What is prototype chain?

Every object in JavaScript has a built-in property, which is called its *prototype*. The prototype is itself an object, so the prototype will have its own prototype, making what's called a prototype chain. The chain ends when we reach a prototype that has `null` for its own prototype.

When you try to access a property of an object: if the property can't be found in the object itself (own property), the prototype is searched for the property. If the property still can't be found, then the prototype's prototype is searched, and so on until either the property is found, or the end of the chain is reached, in which case `undefined` is returned.

```js
const myObject = {
  city: "Madrid",
  greet() {
    console.log(`Greetings from ${this.city}`);
  },
};

myObject.greet(); // Greetings from Madrid
```

```js
Object.getPrototypeOf(myObject); // Object { } => Object.prorotype
```

`Object.prototype` is the most basic prototype, that all objects have by default. The prototype of `Object.prototype` is `null`, so it's at the end of the prototype chain

https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes

## JSON 

### What is JSON and its common operations?

*JavaScript Object Notation (JSON)* is a standard text-based format for representing structured data based on JavaScript object syntax. It is commonly used for transmitting data in web applications.

it can be used independently from JavaScript, and many programming environments feature the ability to read (parse) and generate JSON

JSON exists as a string, it needs to be converted to a native JavaScript object to access the data

We can also convert arrays to/from JSON.

```js
{
  "browsers": {
    "firefox": {
      "name": "Firefox",
      "pref_url": "about:config",
      "releases": {
        "1": {
          "release_date": "2004-11-09",
          "status": "retired",
          "engine": "Gecko",
          "engine_version": "1.7"
        }
      }
    }
  }
}
```

### How do you parse JSON string?
You can use the `JSON.parse()` method to convert the above JSON string into a JavaScript object:
```js
const jsonText = `{
  "browsers": {
    "firefox": {
      "name": "Firefox",
      "pref_url": "about:config",
      "releases": {
        "1": {
          "release_date": "2004-11-09",
          "status": "retired",
          "engine": "Gecko",
          "engine_version": "1.7"
        }
      }
    }
  }
}`;

console.log(JSON.parse(jsonText));
```
### Why do you need JSON?

### What is the purpose JSON stringify?
The `JSON.stringify()` method converts a JavaScript value to a JSON string, optionally replacing values if a *replacer function* is specified or optionally including only the specified properties if a *replacer array* is specified.

```js
JSON.stringify(value)
JSON.stringify(value, replacer)
JSON.stringify(value, replacer, space)
```

```js
JSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify([NaN, null, Infinity]); // '[null,null,null]'
JSON.stringify({ x: 5 }); // '{"x":5}'
JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)); // '"2006-01-02T15:04:05.000Z"'
JSON.stringify({ x: 5, y: 6 }); // '{"x":5,"y":6}'
```

```js
function replacer(key, value) {
  // Filtering out properties
  if (typeof value === "string") {
    return undefined;
  }
  return value;
}

const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};
JSON.stringify(foo, replacer);
// '{"week":45,"month":7}'
```

```js
const foo = {
  foundation: "Mozilla",
  model: "box",
  week: 45,
  transport: "car",
  month: 7,
};

JSON.stringify(foo, ["week", "month"]);
// '{"week":45,"month":7}', only keep "week" and "month" properties
```
space parameter
```js
console.log(JSON.stringify({ a: 2 }, null, " "));
/*
{
 "a": 2
}
*/
```
/w localStorage
```js
// Creating an example of JSON
const session = {
  screens: [],
  state: true,
};
session.screens.push({ name: "screenA", width: 450, height: 250 });
session.screens.push({ name: "screenB", width: 650, height: 350 });
session.screens.push({ name: "screenC", width: 750, height: 120 });

// Converting the JSON string with JSON.stringify()
// then saving with localStorage in the name of session
localStorage.setItem("session", JSON.stringify(session));

// Example of how to transform the String generated through
// JSON.stringify() and saved in localStorage in JSON object again
const restoredSession = JSON.parse(localStorage.getItem("session"));

// Now restoredSession variable contains the object that was saved
// in localStorage
console.log(restoredSession);
```
### How do you define JSON arrays?
JSON Array is almost same as JavaScript Array. JSON array can store values of type `string`, `array`, `boolean`, `number`, `object`, or `null`. In JSON array, values are separated by commas. Array elements can be accessed using the [] operator.

## Array methods 

### What is the purpose of the array slice method?
returns a new array copying to it all items from index `start` to `end` (not including `end`).
```js
arr.slice([start], [end])
```
```js
let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); // e,s (copy from 1 to 3)

alert( arr.slice(-2) ); // s,t (copy from -2 till the end)
```
`arr.slice()` creates a copy of `arr` -- often used to obtain a copy for further transformations that should not affect the original array.

### What is the purpose of the array splice method?
```js
arr.splice(start[, deleteCount, elem1, ..., elemN])
```
```js
let arr = ["I", "study", "JavaScript"];

arr.splice(1, 1); // from index 1 remove 1 element

alert( arr ); // ["I", "JavaScript"]
```
```js
let arr = ["I", "study", "JavaScript", "right", "now"];

// remove 3 first elements and replace them with another
arr.splice(0, 3, "Let's", "dance");

alert( arr ) // now ["Let's", "dance", "right", "now"]
```

```js
let arr = ["I", "study", "JavaScript"];
// from index 2
// delete 0
// then insert "complex" and "language"
arr.splice(2, 0, "complex", "language");

alert( arr ); // "I", "study", "complex", "language", "JavaScript"
```
```js
let arr = [1, 2, 5];

// from index -1 (one step from the end)
// delete 0 elements,
// then insert 3 and 4
arr.splice(-1, 0, 3, 4);

alert( arr ); // 1,2,3,4,5
```
### What array methods do you know?

https://javascript.info/array-methods#summary

**To add/remove elements:**

`push(...items)` – adds `items` to the end,

`pop()` – extracts an item from the end,

`shift()` – extracts an item from the beginning,

`unshift(...items)` – adds `items` to the beginning.

`splice(pos, deleteCount, ...items)` – at index `pos` deletes `deleteCount` elements and inserts `items`.

`slice(start, end)` – creates a new array, copies elements from index `start` till `end` (not inclusive) into it.

`concat(...items)` – returns a new array: copies all members of the current one and adds `items` to it. If any of `items` is an array, then its elements are taken.

**To search among elements:**

`indexOf/lastIndexOf(item, pos)` – look for `item` starting from position `pos`, return the index or -1 if not found.

`includes(value)` – returns true if the array has `value`, otherwise false.

`find/filter(func)` – filter elements through the `func`, return first/all values that make it return true.

`findIndex` is like `find`, but returns the index instead of a value.

**To iterate over elements:**

`forEach(func)` – calls `func` for every element, does not return anything.

**To transform the array:**

`map(func)` – creates a new array from results of calling `func` for every element.

`sort(func)` – sorts the array in-place, then returns it.

`reverse()` – reverses the array in-place, then returns it.

`split/join` – convert a string to array and back.

`reduce(func, initial)` – calculate a single value over the array by calling `func` for each element and passing an intermediate result between the calls.

**Additionally:**

`Array.isArray(value)` checks value for being an array, if so returns true, otherwise false.

    ! methods `sort`, `reverse` and `splice` modify the array itself.

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array

- Static methods
  - `Array.from()` -- Creates a new Array instance from an array-like object or iterable object.
  - `Array.isArray()` -- Returns true if the argument is an array, or false otherwise.
  - `Array.of()` -- Creates a new Array instance with a variable number of arguments, regardless of number or type of the arguments.

- Instance methods
  - `Array.prototype.at()` -- Returns the array item at the given index. Accepts negative integers, which count back from the last item.
  - `Array.prototype.concat()` -- Returns a new array that is the calling array joined with other array(s) and/or value(s).
  - `Array.prototype.entries()` -- Returns a new array iterator object that contains the key/value pairs for each index in an array
  - `Array.prototype.every()` -- Returns true if every element in the calling array satisfies the testing function.
  - `Array.prototype.filter()` -- Returns a new array containing all elements of the calling array for which the provided filtering function returns true.
  - `Array.prototype.find()` -- Returns the value of the first element in the array that satisfies the provided testing function, or `undefined` if no appropriate element is found.
  - `Array.prototype.findIndex()` -- Returns the index of the first element in the array that satisfies the provided testing function, or -1 if no appropriate element was found.
  - `Array.prototype.flat()` -- Returns a new array with all sub-array elements concatenated into it recursively up to the specified depth.
  - `Array.prototype.forEach()` -- Calls a function for each element in the calling array
  - `Array.prototype.includes()` -- Determines whether the calling array contains a value, returning true or false as appropriate.

    ```js
    const fruits = ['Apple', 'Banana'];

    fruits.includes('Banana'); // true
    fruits.includes('Cherry'); // false

    // If indexOf() doesn't return -1, the array contains the given item.
    fruits.indexOf('Banana') !== -1; // true
    fruits.indexOf('Cherry') !== -1; // false
    ```
  - `Array.prototype.indexOf()` -- Returns the first (least) index at which a given element can be found in the calling array.
  - `Array.prototype.join()` -- Joins all elements of an array into a string.
  - `Array.prototype.map()` -- Returns a new array containing the results of invoking a function on every element in the calling array.
  - `Array.prototype.pop()` -- Removes the last element from an array and returns that element.
  - `Array.prototype.push()` -- Adds one or more elements to the end of an array, and returns the new length of the array.
  - `Array.prototype.reduce()` -- Executes a user-supplied "reducer" callback function on each element of the array (from left to right), to reduce it to a single value.

    ```js
    const array1 = [1, 2, 3, 4];

    // 0 + 1 + 2 + 3 + 4
    const initialValue = 0;
    const sumWithInitial = array1.reduce(
      (previousValue, currentValue) => previousValue + currentValue,
      initialValue
    );

    console.log(sumWithInitial);
    // expected output: 10
    ```
  - `Array.prototype.reverse()` -- Reverses the order of the elements of an array in place. (First becomes the last, last becomes first.)
  - `Array.prototype.shift()` -- Removes the first element from an array and returns that element.
  - `Array.prototype.slice()` -- Extracts a section of the calling array and returns a new array.
  - `Array.prototype.some()` -- Returns true if at least one element in the calling array satisfies the provided testing function.
  - `Array.prototype.sort()` -- Sorts the elements of an array in place and returns the array.
  - `Array.prototype.splice()` -- Adds and/or removes elements from an array.
  - `Array.prototype.toString()` -- Returns a string representing the calling array and its elements. Overrides the Object.prototype.toString() method.

### What is the difference between Array.forEach() and Array.map()? 
- `Array.forEach()` - calls a function on each element in an array
- `Array.map()` - creates a new array populated with the results of calling a provided function on every element in the calling array

## Functions 

### What are lambda or arrow functions?
An arrow function expression is a compact alternative to a traditional function expression.

```js
// Traditional Anonymous Function
(function (a) {
  return a + 100;
});

// Arrow Function Break Down

// 1. Remove the word "function" and place arrow between the argument and opening body bracket
(a) => {
  return a + 100;
};

// 2. Remove the body braces and word "return" — the return is implied.
(a) => a + 100;

// 3. Remove the argument parentheses
a => a + 100;
```
### What is a first class function?
functions in JS are treated like any other variable: a function can be passed as an argument to other functions (callback function), can be returned by another function and can be assigned as a value to a variable.

### What is a first order function?
### What is a higher order function?
### What is a unary function?
### What is the currying function?
### What is a pure function?
### What are closures?
### What is IIFE(Immediately Invoked Function Expression)?
### What is an anonymous function?
The main difference between a `function expression` and a `function declaration` is `the function name`, which can be omitted in function expressions to create anonymous functions.

## Async JavaScript 

### What is a callback function?
A callback function is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action.
```js
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;
  script.onload = () => callback(script);
  document.head.append(script);
}

loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', script => {
  alert(`Cool, the script ${script.src} is loaded`);
});
```
### Why do we need callbacks?

### What is a callback hell?
doing several asynchronous operations in a row with callbacks

nested callbacks stacked below one another forming a pyramid structure: every callback depends/waits for the previous callback

```js
loadScript('/my/script.js', function(script) {

  loadScript('/my/script2.js', function(script) {

    loadScript('/my/script3.js', function(script) {
      // ...continue after all scripts are loaded
    });

  });

});

```
### What is a promise?
A `Promise` is an object representing the eventual completion or failure of an asynchronous operation, to which you attach callbacks, instead of passing callbacks into a function

- A `producing code` that does something and takes time.
- A `consuming code` that wants the result of the “producing code” once it’s ready.
- A promise is a special JavaScript object that links the `producing code` and the `consuming code` together: the `producing code` takes whatever time it needs to produce the promised result, and the `promise` makes that result available to all of the subscribed code when it’s ready.

```js
let promise = new Promise(
  function(resolve, reject) { // executor (the producing code; resolve and reject are callbacks provided by JS engine)
    setTimeout(() => resolve('done'), 1000);
  // after 1 second signal that the job is done with the result "done"
  }
);
```
or
```js
let promise = new Promise(function(resolve, reject) {
  setTimeout(() => reject(new Error("Whoops!")), 1000);
});
```
The executor runs automatically and attempts to perform a job. When it is finished, it calls `resolve(value)` (if the job is finished successfully, with result `value`) or `reject(error)` if an error has occurred, `error` is the error object

Consuming functions can be registered (subscribed) using the methods `.then` and `.catch`.

```js
promise.then(
  // resolve runs the first function in .then
  result => alert(result), // shows "done!" after 1 second
  error => alert(error) // doesn't run
);
```
or
```js
promise.then(
  // reject runs the second function in .then
  result => alert(result), // doesn't run
  error => alert(error) // shows "Error: Whoops!" after 1 second
);
```

If we’re interested only in errors, then we can use `null` as the first argument: `.then(null, errorHandlingFunction)`. Or we can use `.catch(errorHandlingFunction)`

```js
let promise = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error("Whoops!")), 1000);
});
// .catch(f) is the same as promise.then(null, f)
promise.catch(alert); // shows "Error: Whoops!" after 1 second
```
do a generic cleanup, no matter what the outcome was:

```js
new Promise((resolve, reject) => {
  setTimeout(() => resolve("value"), 2000);
})
  // runs when the promise is settled, doesn't matter successfully or not
  .finally(() => alert('Promise ready')) // triggers first
  .then(result => alert(result)); // <-- .then shows "value"
```
### Why do you need a promise?

### What are the three states of promise?

The `promise` object returned by the `new Promise` constructor has these internal properties:
**state** — initially `pending`, then (`settled` promise) changes to either `fulfilled` when resolve is called or `rejected` when reject is called.
**result** — initially `undefined`, then changes to `value` when `resolve(value)` is called or `error` when `reject(error)` is called.

### What is promise chaining?
we have a sequence of asynchronous tasks to be performed one after another
Here each `loadScript` call returns a promise, and the next `.then` runs when it resolves. Then it initiates the loading of the next script.

```js
function loadScript(src) {
  return new Promise(function(resolve, reject) {
    let script = document.createElement('script');
    script.src = src;

    script.onload = () => resolve(script);
    script.onerror = () => reject(new Error(`Script load error for ${src}`));

    document.head.append(script);
  });
}

loadScript("/article/promise-chaining/one.js")
  .then(function(script) {
    return loadScript("/article/promise-chaining/two.js");
  })
  .then(function(script) {
    return loadScript("/article/promise-chaining/three.js");
  })
  .then(function(script) {
    // use functions declared in scripts
    // to show that they indeed loaded
    one();
    two();
    three();
  });
```
or w/ arrow functions:
```js
loadScript("/article/promise-chaining/one.js")
  .then(script => loadScript("/article/promise-chaining/two.js"))
  .then(script => loadScript("/article/promise-chaining/three.js"))
  .then(script => {
    // scripts are loaded, we can use functions declared there
    one();
    two();
    three();
  });
```
### What is promise.all?
we want many promises to execute in parallel and wait until all of them are ready

`Promise.all` rejects as a whole if any promise rejects.

```js
let promise = Promise.all(iterable); // iterable usually is, an array of promises
```

```js
Promise.all([
  new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
  new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
  new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3
]).then(alert); // 1,2,3 when promises are ready: each promise contributes an array member
```
map an array of data into an array of promises, and then wrap that into `Promise.all`:

```js
let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/remy',
  'https://api.github.com/users/jeresig'
];

// map every url to the promise of the fetch
let requests = urls.map(url => fetch(url));

// Promise.all waits until all jobs are resolved
Promise.all(requests)
  .then(responses => responses.forEach(
    response => alert(`${response.url}: ${response.status}`)
  ));
```
### What is the purpose of race method in promise?
Similar to [`Promise.all`](https://github.com/szkertesz/crack-ti/blob/main/questions/js.md#what-is-promiseall), but waits only for the first settled promise and gets its result (or error).

```js
Promise.race([
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Whoops!")), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).then(alert); // 1
```
### What is the use of setTimeout?
We may decide to execute a function not right now, but at a certain time later. That’s called *scheduling a call*.

`setTimeout` allows us to run a function once after the interval of time.

```js
function sayHi() {
  alert('Hello');
}

setTimeout(sayHi, 1000); // calls sayHi() after one second
```
cancelink w/ `clearTimeout`:

```js
let timerId = setTimeout(() => alert("never happens"), 1000);
alert(timerId); // timer identifier

clearTimeout(timerId);
alert(timerId); // same identifier (doesn't become null after canceling)
```
nested `setTimeout`

```js
/** instead of:
let timerId = setInterval(() => alert('tick'), 2000);
*/

let timerId = setTimeout(function tick() {
  alert('tick');
  timerId = setTimeout(tick, 2000); // (*)
}, 2000);
```
### What is the use of setInterval?
We may decide to execute a function not right now, but at a certain time later. That’s called *scheduling a call*.

`setInterval` allows us to run a function repeatedly, starting after the interval of time, then repeating continuously at that interval.

This will show the message every 2 seconds. After 5 seconds, the output is stopped:

```js
// repeat with the interval of 2 seconds
let timerId = setInterval(() => alert('tick'), 2000);

// after 5 seconds stop
setTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);
```

the time taken by func's execution *consumes* a part of the interval => if the function always executes longer than `delay` ms, then the calls will happen without a pause at all

### What is an event loop?
There’s an endless loop, where the JavaScript engine waits for tasks, executes them starting with the oldest task and then sleeps, waiting for more tasks.

It may happen that a task comes while the engine is busy, then it’s enqueued.

- Rendering never happens while the engine executes a task. Changes to the DOM are painted only after the task is complete.

- If a task takes too long, the browser can’t do other tasks, such as processing user events.

**Macrotasks & Microtasks**
Microtasks are usually created by promises: an execution of `.then/catch/finally` handler or `await` becomes a microtask.

Immediately after every macrotask, the engine executes all tasks from microtask queue, prior to running any other macrotasks or rendering or anything else.


```js
setTimeout(() => alert("timeout")); // timeout shows last, because it’s a macrotask.

Promise.resolve()
  .then(() => alert("promise")); // promise shows second, because .then passes through the microtask queue, and runs after the current code.

alert("code"); // code shows first, because it’s a regular synchronous call
```

1. Dequeue and run the oldest task from the macrotask queue (e.g. “script”).
2. Execute all microtasks:
   - While the microtask queue is not empty:
     - Dequeue and run the oldest microtask.

3. Render changes if any.
4. If the macrotask queue is empty, wait till a macrotask appears.
5. Go to step 1.

To schedule a new macrotask:
- Use zero delayed `setTimeout(f)`.

To schedule a new microtask:
- Use queueMicrotask(f).
- Also promise handlers go through the microtask queue.


### What is call stack?

## Common 

### What is a strict mode in javascript?
- is a way to opt in to a restricted variant of JavaScript
- has different semantics from normal code

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode

### What are PWAs?

shorthand used initially by Google for the concept of creating a flexible, adaptable app using only web technologies, which is

- *Discoverable*, so the contents can be found through search engines. <=  `Web app manifest`, which defines features of an app such as name, icon, splash screen, and theme colors in a JSON-formatted manifest file.
- *Installable*, so it can be available on the device's home screen or app launcher. <= web app installation, service workers
- *Linkable*, so you can share it by sending a URL.
- *Network independent*, so it works offline or with a poor network connection. <= service workers, Cache API, Web Storage, IndexedDB
- *Progressively enhanced*, so it's still usable on a basic level on older browsers, but fully-functional on the latest ones.
- *Re-engageable*, so it's able to send notifications whenever there's new content available.
- *Responsively designed*, so it's usable on any device with a screen and a browser—mobile phones, tablets, laptops, TVs, refrigerators, etc.
- *Secure*, so the connections between the user, the app, and your server are secured against any third parties trying to get access to sensitive data.
### How do you validate an email in javascript?

### How do you get the current url with javascript?
```js
window.location.href
```
### What is tree shaking?
The removal of dead code.

It relies on the `import` and `export` statements to detect if code modules are exported and imported for use between JavaScript files.
In practice, we use module bundlers (e.g., webpack or Rollup) to automatically remove dead code when bundling multiple JavaScript files into single files.

### What is memoization?
https://www.freecodecamp.org/news/memoization-in-javascript-and-react/

### What are modules?
language-level module system appeared in the standard in 2015

A module is just a file. One script is one module.

- `export` keyword labels variables and functions that should be accessible from outside the current module.
- `import` allows the import of functionality from other modules.
```js
// 📁 sayHi.js
export function sayHi(user) {
  alert(`Hello, ${user}!`);
}
```
…Then another file may import and use it:
```js
// 📁 main.js
import {sayHi} from './sayHi.js';

alert(sayHi); // function...
sayHi('John'); // Hello, John!
```
- we must tell the browser that a script should be treated as a module, by using the attribute `<script type="module">`
- Modules always work in strict mode.
- Modules work only via HTTP(s), not locally
- Each module has its own, local top-level scope: variables and functions from a module are not seen in other scripts -- we use import/export instead of relying on global variables
- Module scripts are deferred by default
  - downloading external module scripts <script type="module" src="..."> doesn’t block HTML processing, they load in parallel with other resources.
  - module scripts wait until the HTML document is fully ready (even if they are tiny and load faster than HTML), and then run.
  - relative order of scripts is maintained: scripts that go first in the document, execute first.
- Module code is executed only once. Exports are created once and shared between importers.

### Why do you need modules?
### How do you detect a mobile browser?
### How do you detect javascript disabled in the page?
### What is a rest parameter?
### What is a spread operator?
### How do you encode an URL?
### How do you decode an URL?
### What is nodejs?
